# Ring-2025-演进规划

> [!TIP|label:tip]
>
> 保持耐心，守住寂寞，持续产出。
> 

## 一、项目组织方案
1. 一个package中支持多个源代码文件，main package只能有一个文件，方便 ring run 命令
2. 每个文件中支持定义多个global 块，能够自动分析初始化顺序
3. import 导入packages支持别名
4. 支持使用import导入package的全局变量，类定义
5. 被import的package中，支持使用 derive native函数
6. 比较类定义，类的类型是否一致
7. 支持并发编译，提升编译速度
8. 设计字节码文件，能够导出一个大的压缩字节码文件，能够解析，能够方便进行一键分发
9. 前端后端的解耦
10. 支持linux macos windows
11. 设计项目的组织、编译、链接

## 二、动态类型分配
1. 落地增量式垃圾回收算法、验证算法的正确性
2. 优化类的内存排布，新的内存分配器
3. 多维数组+类的内存排布
4. 优化数据的内存排布
5. free-value的内存排布
6. 匿名函数的内存分配
7. 理清用户行为的深度copy、浅copy和虚拟机层面的深度copy、浅copy

## 三、数据类型和运算
1. string 支持更多的标准库操作：切片，find prefix suffix split join
2. 支持小string内存优化
3. 支持string常量去重优化
4. 多行string
5. string的format
6. string 支持 utf-8
7. 基础数据类型的隐式转换，显式转换
8. 类对象的比较
9. 括号运算符
10. 指针和引用
11. 无符号类型
12. 2进制/16进制类型常量数据解析
13. 新数据类型：元组、枚举类型
14. 放弃字符串拼接运算符 .. , 直接使用+
15. array 支持更多的标准库操作：切片([a:b])，find，拼接
16. tuple 数据类型
17. 科学计数法表示
18. typedef 支持定义类型别名，tuple，enum
19. 支持类型推导
20. 支持 const 常量

## 四、函数 方法 匿名函数 闭包
1. return语句的强制检查
2. 匿名函数赋值给field
3. 方法赋值给匿名函数
4. 捕获是值捕获还是引用捕获
5. 能够在标准库中定义类，类中的method是native函数
6. 支持在 数组、类 中存放 匿名函数
7. 匿名函数需要补齐的字节码
   1. pop_static_closure push_static_closure
   2. pop_free_class_ob push_free_class_ob
   3. push_array_closure pop_array_closure
   4. array_append_closure array_pop_closure
   5. pop_field_closure push_field_closure
   6. new_array_closure new_array_literal_closure
   7. range_array_closure

## 五、控制语句
1. 优化 return break continue 语句
   1. return 与函数定义的不符合，控制语句中 不可能return
2. 优化 for-range 对应的语句和字节码，in 是否多余
3. 思考错误处理方式，不能跟golang一样垃圾
4. defer语句对应的字节码优化
5. for 语句中定义新的局部变量
6. switch 语句支持

## 六、协程
1. 协程之间传递数据、共享数据、yield如何返回数据
2. 协程与标准库，io net，异步
3. 支持多协程的并发式调度
4. 协程绑定cpu
5. 协程模型：唤醒、调度、回收，引入协程调度器

## 七、标准库
1. io
2. net
3. json
4. curl
5. fmt 支持格式控制，占位，显示类型
6. reflect 更高级：获取field字段类型
7. runtime 获取运行时
8. 支持在 std native函数，返回ring标准的 class, 如何实现，如：fn get_caller() -> (CallInfo);

## 八、工具链
1. 优化rdb原生调试工具
   1. step opcode: 一次执行一个ring虚拟机字节码
   2. break set 还有个bug, 如果某行为注释或者空行, breakpoint 可能不会生效
2. vscode 生态工具插件
   1. 语法高亮插件
   2. 语义查错插件
   3. 调试器插件 dap协议：可以查看call-stack, local-variable, 控制运行

## 九、优化编译流程和编译报错提示

### 编译流程
1. 创建语法树
2. 上下文语义补全，补全定义，引用（当前fix ast的功能）
3. 语义check、报错提示：可以积累错误的数量，一个函数内错误不能超过5个。可以以函数为单元进行并发语法分析
4. 语法树裁剪优化，类型转换
5. 生成字节码


1. 积累错误
2. 并发分析
3. 错误提示更加人性化，显示行数和列数
4. 虚拟机panic错误优化，快速生成诊断信息

## 十、全局视角优化统一代码风格


## 十一、example.ring.wiki 网站建设



## Ring编译器开发内容流程细分

工作细化Tag：

- Background: 调研相关工作
- Proposal: 提案相关工作
- Feature:  新特性
- Fix:  修正
- Update: 逻辑更新
- Refactor: 重构
- Optimize: 优化
- Test: 测试
- Doc: 文档
- Other: 其他

-----------------------------


## v0.3.1-beta

1. free-value 支持 array
2. 增量式垃圾回收
3. 丰富字符串的标准库
4. 重新审视 比较运算符 bool/int/int64/double/string
5. int int64 的隐式转换，提高使用的便利性
6. 写一个ring调试器
7. 支持 linux/window 运行
8. 错误处理
9. 基于图的控制流分析技术，死代码、不合法return语句 等





----------------------

#### 1. 代码的语义分析，是否要进行深度复制

1. 是否深度复制，需要取决于语义，需要 deep_copy 语句 TODO:

deep_copy_class_ob
deep_copy_array


这里设计的有点混乱

bug 1:

```
class_object.ClassField = value;
// 这里当前是 shallow copy，需要改成 deep copy
```


bug 2:
```
var string local_string_value_0;
local_string_value_0 = "12345678";

local_job_value_0.String = local_string_value_0;
```
这里没有发生string 的copy，再修改string 会出现问题，需要修正



4. 数组中的元素，push pop get set; deep/shallow TODO:
5. 类中的元素 a.b = c;  deep/shallow TODO:
6. 全局变量/局部变量 赋值；deep/shallow TODO:

#### 2. 这个操作会让内存 初始化两次，如何优化？？？
   
global_int_array_0 = new int[8];


#### 5. Update: 批量扫清 generate 中的 todo list TODO:




#### 7. 利用 dot 将当前的内存分布绘制一个分布图

1. 在运行过程中开启 trace_closure_free_value=1 输出 closure 的 trace
2. 将 内存分布 生成一个 d2源码文件
3. 通过 d2 工具将 d2源码文件翻译成图片, 可以更直观的展示 内存分布的情况
4. https://d2lang.com/









#### 16. constant_pool_grow(executer, 1) 性能存在问题







#### 21. new_array_literal_xxx 字节码 不能初始化超过 65536 个元素 TODO:






#### 24. 删除 RVM_Array::type TODO:



#### 29. throw_runtime_err 在macos-m1 上 有问题

显示不正确





#### 32. 关于return语句详细的语义检查


3. 如果 function 中 缺少 return语句，应该报错出来 TODO:

这里需要展开一个大的领域：控制流分析
   
- 终止块识别：出度为0的块是终止块，必须包含return语句
- 路径连通性：从入口到出口必须存在至少一条全返回路径
- 不可达块检测：入度为0的非入口块是死代码




#### 35. Feature: runtime_stack 的空间是 写死的 1024*1024, 应该计算出来 TODO:

通过字节码来计算处理



#### 36. Feautre: 函数参数需要重新声明一下

RVM_Value std_lib_runtime_call_info(Ring_VirtualMachine* rvm,
                                    unsigned int arg_count, RVM_Value* args,
                                    unsigned int* return_size, RVM_Value** return_list)



### A0. Featrue: 编译流程重构优化

1. 能够积累编译错误

当前错误不能积累的原因是，如果某个check没过，还继续向下走流程，他们可能会panic，所以要细分编译流程

2. 能够并发编译

依赖图构建和分析，不能循环，并发去解析

### A. Feature: 落地垃圾回收机制


提前考虑的问题：
1. 动态内存分配优化
2. gc 能够展示出回收了多少数据，要精确

需要考虑这几个问题：
1. 采用什么算法
2. 垃圾回收的时机：如何触发、频率
3. 每次回收的数量：全量、还是增量
4. 垃圾回收如何系统性测试：算法的正确性，回收垃圾的速度、吞吐
5. 完善好虚拟机操作，数据是深度copy还是浅copy
6. 内存分配的优化
7. 哪里触发写屏障 Write Barrier
   1. 对象的object 引用设置
   2. 往 stack 上 放置object
   3. array 添加数组
8. 如何验证回收的正确性
   1. 重复读写对象，看看在垃圾回收之后，对象能否被正常访问


如何触发写屏障：
1. class field为 string/array
2. array item 为 string/array
3. free_value 自由变量
4. 运行栈上的对象


当前对于内场的分配有点不太熟悉了，通过打印内存分配日志先熟悉一下：
1. 分配 string array class closure free-value 这种类型都要详细打印出来
2. 销毁内存的时候也要详细打印出来


代码设计：
1. GarbageCollector
2. 选择不同的回收算法
3. 记录回收的状态转移图
4. 记录回收的次数
5. 记录回收的时间
6. 记录回收的内存大小
7. 实现混合写屏障 Dijkstra插入写屏障 Yuasa删除写屏障
   1. 栈上不进行写屏障，最后统一进行STW
   2. 堆上进行写屏障


3. garbage_collect 函数改名为 vm::gc();

#### 先保障 stw 垃圾回收算法的正确性和可调试性 TODO:

系统性测试
1. array
2. string
3. class
4. 自由变量 TODO:
   1. array
   2. string
   3. class


自由变量逃逸的时候，需要支持 deep copy array/class/string TODO:


这里有个问题没有想好，那就是 closure 中 free_value_list 该在什么时候释放，因为 deep_copy_closure 没有深度复制 free_value_list, 会内存错误。

free_value_list 只是一个指针，他不存储数据，但是存储了 指向 RVM_Value 的指针，所以他的生命周期该如何控制


#### 1. 数组分配到内存池上，方便进行内存的查看，后续完全优化之后，可以通过 宏 一键disable

#### 2. length capacity 返回的应该是 int 还是 int64

TODO: 这里有个依赖项，就是 int 和 int64 的隐式转换


#### 4. 使用 mimalloc 分配内存



### D4. Feature: 关于函数可变参数的匹配检查  TODO:





### G. Feature: typedef 语法细节优化




3. 定义类型别名 TODO:

```
typedef TaskIsDone = bool;
typedef TaskTag = int;
typedef TaskType = string;
typedef TaskList = string[];

是否要支持递归定义：
typedef TaskType = string;
typedef TaskName = TaskType;
```

他们都是别名，最终都会映射到基础数据类型+派生数据类型


4. 如果后续支持 定义元组类型 TODO:

```
typedef TaskTuple = tuple(bool, int, string);
```


5. 如果后续支持 enum TODO:

```
// TaskType 是个类型
// Task::A Task::B 本质上是个常量
typedef TaskType = enum string {
	A = "A";
	B = "B";
};
// 后续可以使用

fmt::println(TaskType::A);

// TaskTemp 是个类型
// Task::A Task::B 本质上是个常量
typedef TaskTemp = enum Task { // Task is class
	A = Task {

	};
	B = Task {

	};
}
```

使用 enum
TaskType::A
TaskTemp::A

如果 import package 的 enum
package::TaskType::A


6. 新增语法限制，提高可阅读性和辨识度，不满足则会编译报错提示


- import package 导入别名的时候，也不能大写开头 TODO: 




### N. Feature: 数组为空/访问越界 虚拟机应该panic报错，同时抛出堆栈，方便排错 

TODO: 还需要支持：
1. out of memory


### O. Feature: 新语法: 复杂函数调用

v0.3.0 还需要扩展支持到 launch关键字上


3. TODO: 需要继续递归推导，支持更复杂的调用


如果匿名函数更多嵌套  ✅
    
```
return_closure()()();
```

返回object，直接调用method
    
```
return_object().a();
```

带有 package_posit
    
```
a::b[0]();
```




### Q. Feature: 目前函数调用 方法调用是分成了两个 TODO:

要想办法将两个融合在一起，可以参考 FunctionCall的实现

这样有什么特性，可以同时应用到 function-call 和 method-call



### Z. Feature: rdb TODO: 优先级放低

需要支持的命令有：
1. print
2. var_dump
3. typeof
4. call 
支持 print var_dump typeof a.b.c 这种复杂操作

解析语法，生成字节码，运行字节码从虚拟机获取到对应的值

这里实现的行为有点类似于 repl 了

如：

```
print a
print b[0]
print c[0,0]
print d.e
print d[0].e.f[0] a

call a(1, 2) // 调用函数查看返回值
call e(c, d)
```



1. 上下文堆栈获取
2. 变量符号的解析
3. 定位栈/堆上地址
4. 获取类型，获取值
5. 格式化输出

### Y. Feature: class在定义的时候，要判断是否有循环定义，不然在变量初始化的时候会出现问题 TODO:

需要做 编译错误处理，


### X.
4. runtime 新增以下函数 TODO:
   - runtime::resume()
   - runtime::yield()
   - runtime::获取协程的状态
   - runtime::获取协程的数量

------------


### 关于函数调用相关对应的字节码


1. 调用 ring编译器内部定义 的 native 函数

```
push_argument
push_argument_num
push_func
invoke_func_native
```


2. 普通derive函数调用对应的字节码

```
push_argument
push_argument_num
push_func
invoke_func
```


3. 调用匿名函数变量

```
push_arguemnt
push_argument_num
push_stack_closure
invoke_closure
```


4. 调用类中的method

```
push_arguemnt
push_argument_num
push_[static/stack]_class_ob
push_method
invoke_method
```


5. 类中的field为匿名函数类型，调用field

```
push_argument
push_argument_num
push_[static/stack]_class_ob
push_field_closure
invoke_closure
```