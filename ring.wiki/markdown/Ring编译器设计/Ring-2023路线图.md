# Ring 2023年 规划表

- 更新时间：```2023-08-30```

2022年下半年因为面试的原因，没有尽力去全力以赴的完善Ring，在此定义一个2023年的todo list。

> [!TIP|label:tip]
> 
> 世界上哪有不枯燥的事情呀。
> 
> 研究和学习一定要不甘寂寞，如果要是累了，就可以放天假呀。
> 
> Ring还是非常有必要研究好的，虽然世界上有很多类似的语言，只要集中精力发展，Ring的未来还是会让现在的自己吃惊的！
> 

## 年总规划

1. 通读 diksam_v0.4 
   - https://github.com/GeneralSandman/diksam_v0.4
   - 里边还是有很多值得借鉴的地方
2. 通读 Lua 5.x版本
   1. 好好掌握 Lua的语法用法
   2. 力求完全掌握设计逻辑、包括协程、table
   3. 重新读那本 用Go语言实现Lua虚拟机
3. 完善Ring的基本功能
   1. 完善栈式虚拟机
   2. 面向对象 Class
   3. 数组 Array
   4. 字符串 String
   5. 完善语义分析 报错机制
   6. Any类型
   7. 实现可变参数 
   8. 完善内置 printf 函数  很重要  可变参数 format
   9. package 源代码的组织形式 import/package
   10. 生成字节码 到二进制文件 解析字节码 Dump ByteCode
   11. linux man手册
4. 完善Ring的高级功能
   1.  类型的强制转换 与 隐式转换
   2.  垃圾回收 Grabage Collection
   3.  闭包 Closure
   4.  实现反射 获取变量的类型 参考 go
   5.  优化内置 native-lib
   6.  调试器 Debuger
   7.  交互式编程 
   8.  lsp
   9.  优化控制语句中  break continue return
5. 实现相对完善的官方标准库 fmt sys math debug strings
6. 将 栈式虚拟机 转为 寄存式虚拟机
7. 支持Ring Eval 
   1. e.g.  ./bin/lua eval "fmt::println_string("hello world");"
8. chatgpt + 智能终端 + ring -> 交互式入门ring
9. 学习函数式编程
10. 学习 Ocaml
-----------------------------

## 工作内容流程细分

将工作细化为以下几类工作：
- 调研：深度理解某项功能
- 设计：需求分析、规划，设计语法，设计功能，设计某项功能
- 实现：代码实现
- 测试：完善测试用例


-----------------------------

## 测试集

```
2023-08-31

[Result]:
[Pass/All=114/114]
Usetime:   3s
```



### TODO
1. 函数参数传递 string array class

-----------------------------


## 参考资料汇总


1. Lua设计与实现 基于lua源码对其设计与具体实现进行剖析 https://www.zhihu.com/column/c_1097089416010567680
2. 《自己动手实现Lua：虚拟机、编译器和标准库》代码 https://github.com/GeneralSandman/luago-book
3. https://github.com/GeneralSandman/zhenhuli-lua-learn-node


书籍
1. 《Lua设计与实现》
2. 《自己动手实现Lua：虚拟机、编译器和标准库》
3. 《Lua设计与实现》https://github.com/lichuang/Lua-Source-Internal


-----------------------------


## 2023-09-25周

## 2023-09-18周

1. 完善类数组
2. 函数传递数组、类、类数组
3. 把一键安装完善一下


## 2023-09-11周

## 2023-09-04周

## 2023-08-28周


1. 完成一个简单的垃圾回收机制 mark&swap
2. 通过RVM_RuntimeHeap 去分配内存
3. 自动化测试automated-testing.sh展示有点简陋，看看是否可以用 GoTest来搞定自动化测试
4. 优化语义分析
5. 优化 break continue return goto
6. 修复一下测试用例中的bug ✅
    6.1 minus运算符 操作 double literal的时候失败  ✅
    6.2 var string string_value; 定义之后不使用，不赋值，就进行访问，会内存错误  ✅
7. 好好完善一下 Makefile 各种debug宏 ✅
8. 添加完善一键安装的功能
   1. curl -sSL https://ring.wiki/install.sh | sh  ✅
   2. 在每发布一个 release版本的时候，需要在cos上自动创建对应版本的源码，install安装脚本。通过 github action
9. 实现 jump 跳转指令 重新评估一下 ✅
10. std/vm 标准库获取heap_size native函数需要支持返回值 ✅
11. 要把 invoke_native_function 和 invoke_derive_function 的逻辑合起来
12. bug , 如果一个函数有返回值，但是没有收集返回值，会报错， vm::heap_size() 就会报错 ✅
13. 优化 std lib vm ✅

## 2023-08-21周

1. 完成一个简单的垃圾回收机制 mark&swap
2. 通过RVM_RuntimeHeap 去分配内存
3. 自动化测试automated-testing.sh展示有点简陋，看看是否可以用 GoTest来搞定自动化测试
4. github action workflow 自动构建release 预编译版本 ✅
5. 调研：以下几种编译方式 ✅
    - 源代码安装
    - 预编译安装
    - apt yum brew 软件源安装

6. sizeof() typeof()
7. flex bison 记录的行号不是太准确，比如说，对于function的定义，他会跑到最后一行，应该定位到function 定义的第一行
8. function variable package 的名字不可以一样
clang：报错
 redefinition of 'a' as different kind of symbol
1. ring man <keyword> 快速提示语法结构 ✅

## 2023-08-14周

1. 优化string
    - 动态内存分配 size capacity append 增长
    - 通过索引访问
    - 优化字符串的拼接
    - fmt::to_string 函数，这样的话，是需要反射的，因为传入的变量可以是 int double string
    - size() 获取string的长度
    - fmt::printf("string_value_1 value:{}, size:{}\n", string_value_1, size(string_value_1)); 这也是需要反射
2. 优化完成string之后，优化 fmt 函数， fmt::println() -> io::write(var string str)
3. 优化报错信息 ✅
4. 完成一下测试用例
    函数变量传递 array string class变量
5. 完善 array class
6. 完善 array string
7. 完善多维数组

## 2023-08-07周

1. 优化 runtime_stack 空间，要通过局部变量的数量来动态增长 空间
2. 想清楚全局变量、局部变量 初始化的时机 ✅
2.1 用户在使用ring的时候，不能在 global{} 块中进行全局变量的初始化 ✅
    必须要通过 function init(){} 对全局变量进行初始化
    如果main包import 了 fmt:
        函数的调用顺序为：fmt::init() -> main::init() -> main::main()

测试：在global中 定义全局变量时，初始全局变量。

3. 优化报错信息  将所有的printf 改成 compile_error runtime_error
4. 报错脚本的自动化测试✅

```
通过 ErrorReportContext 来实现
ErrorReportContext context = {

};
ring_compile_error(&context); // 每次ring_compile_error 都要添加一下错误次数，错误次数多了才要退出
```

错误信息

```
./test/998-error-report/error-000.ring:10:0:
|       a;
|       ^......use undeclared variable identifier `a`; E:ERROR_UNDECLARED_IDENTIFIER
Advice: definite variable `a` like: `var bool|int|double|string a;`

./test/998-error-report/error-000.ring:10:0:
|       a;
|       ^......use undeclared variable identifier `a`; E:ERROR_UNDECLARED_IDENTIFIER
Advice: definite variable `a` like: `var bool|int|double|string a;`


1 error generated.
```

compile
synx_
fix_ast

应该细分一下，首先进行语义分析，将错误尽可能的报出来，同时还要积攒数量。
不然的话，fix_ast 可能会出错。
语义分析的时机，编译完成之后，fix_ast 之前。
语义分析的对象是 Package

但是目前一个Package 里边只能有一个PackageUnit 也就是一个包只能有一个文件
一个package 中 可以含有多个 global{} 块。
一个package 中 可以含有多个 init() function{} , 需要通过 @init-priority:1 来生命初始化的优先级

5. 还有一个没有搞明白
    ring 的前端是依赖两个工具flex 和 bison
    如果某个输入有语法错误，那么bison将会直接退出，如何更好的做语法检测。这个还真不太好搞。


-----------------------------

## 2023-07-31周

1. 全面重构类型系统 ✅
2. 修复 int[] double[] 的相关bug ✅
3. 支持数组的初始化赋值，var int[] array = int[]{1, 2, 3, 4}; ✅


-----------------------------

## 2023-07-24周

1. global block 可以有多个，e.g.

```
global {
}
global {
}
```

2. 实现 var int[] array ✅
3. 实现 new int[10], 暂时只支持一维数组 ✅
4. 实现 array = new int[10]; ✅
5. 在 vm 中要实现类型map 的查找和匹配

-----------------------------

## 2023-06-05周

1. 通读《自己动手实现Lua：虚拟机、编译器和标准库》 1-13章
2. 对学到的支持 优化Ring 数组
3. make install bug & 标准库路径写死的bug ✅


-----------------------------

## 2023-05-29周

1. 自己建立一个新的项目，目的是对Lua的字节码有一个较深的理解
   1. 深度学习Lua字节码
   2. 参考 《自己动手实现Lua：虚拟机、编译器和标准库》 1-13章
   3. 参考 https://github.com/GeneralSandman/luago-book
   4. 自己的项目 就是通过CPP来解析Lua的字节码
   5. 项目地址：https://github.com/GeneralSandman/zhenhuli-lua-learn-node


1. zhenhuli-lua-learn-node
   1. 完成了第二章的学习，并可以顺利通过CPP完成对第二章要点的完全掌握。
2. 对知乎专栏Lua模块精讲的学习
   1. Lua设计与实现 基于lua源码对其设计与具体实现进行剖析 https://www.zhihu.com/column/c_1097089416010567680


- 调研标准库的方式
- 参考lua 的 linux man 手册的编写
    https://linux.cn/article-10130-1.html
- Lua 二进制 Chunk的形式，写一个解析程序。学习《自己动手实现Lua：虚拟机、编译器和标准库》 1-13章
- https://github.com/GeneralSandman/luago-book
- lua设计与实现 https://www.zhihu.com/column/c_1097089416010567680

- 思考：全局变量初始化的时机


-----------------------------

## 2023-04-23周

- import 导入包
- std 标准包
- 完善所有的测试用例
- 优化函数的 return list
- 优化 基础 类型 string

- 实现：import 的相关功能 通过import 使用package内的函数     操作符使用 ::  方法的定义也使用 ::✅
- 实现：导入std-fmt包，使用fmt相关库函数，同时要设计好native函数要怎样register才能更方便    --有bug  优先fix
- 实现：import 的相关功能 通过import 使用package内的函数     操作符使用 ::  方法的定义也使用 ::
  - package::函数 ✅
- 实现：导入std-fmt包，使用fmt相关库函数，同时要设计好native函数要怎样register才能更方便     ✅
- 实现：import 的相关功能 通过import 使用package内的函数     操作符使用 ::  方法的定义也使用 ::
  - package::全局变量 ✅
  - package::类定义
- 测试：把所有的测试case统一做了更新  ✅
- 实现：解决 std package 路径的问题
- 调研：调试器  ✅
- 优化：记录原始行号的功能  ✅
- 优化：优化全局变量的一些逻辑  ✅
- 重构：重构了一些代码逻辑  ✅


- 实现：函数的返回类型
- 优化：函数的调用栈
- 优化：函数的局部变量
- 实现：method 使用 self关键字


- 实现：类的构造函数
- 修复：全局变量的初始化
- 修复：类的局部变量的初始化
- 优化：统一 execute 的时候 调用 native derive  function 的方式
- 设计：全局变量初始化的时机 

-----------------------------


## 2023-04-17周

1. 关于源代码切分
- 实现：package import 
- 实现：分package编译 生成字节码 链接

包的名称 不能 和类变量的名称一样，不然会有逻辑问题

- 实现：PacageUnit等 static变量的优化 
- 实现：根据import-package名称去访问 package内的function
- 优化：单文件内 对象的访问
- 实现：class method使用self关键字
- 实现：class method参数和返回值
- 实现：class 构造method
- 测试：完善 class 的相关测试
- 实现：好好实现 std-fmt 库，同时优化 native函数
- 实现：实现比较好用printf函数
- 设计：设计可变参数
- 实现：function method 返回值的严格检验 与 返回值处理

- 实现：源代码的切分编译 ✅
- 实现：编译器从C语言全部转为C++ ✅
- 重构：源代码没有变量编译错误 bug  ✅
- 重构：源代码import为空时编译错误 bug  ✅
- 重构：创建AST时，将 class_definition_list 和 function_list 转为 CPP-vector，更好的管理内存 ✅
- 实现：源代码的切分编译、打包 ✅
- 实现：导入使用 package ✅
- 实现：定义package ✅
- 实现：main 函数  ✅
- 优化：一些编译告警  ✅
- 修复：一些全局变量的默认初始值的bug  ✅
- 实现：去除编译warn告警，提高编译速度 ✅
- 实现：全局变量的定义采用一个比较好的 方式 global{}  ✅
- 实现：import 的相关功能 通过import 使用package内的函数     操作符使用 ::  方法的定义也使用 ::


-----------------------------


## 2023-04-10周

1. 实现面向对象的部分逻辑
- 实现：面向对象 field
- 实现：面向对象 method
- 实现：属性@public @private @constructor

2. 关于字节码二进制
- 实现：源代码与字节码的对应关系 更好的debug
- 理解：Lua字节码的定义，如果生成字节码，如何解析字节码


3. 关于源代码切分
- 实现：package import 
- 实现：分package编译 生成字节码 链接

4. 一些想到的问题
- 实现：属性 @format 应用到某个类的成员函数 定义重载打印对象数据结构的
- 虚拟机：当时设计的不足，不如预先分配一个比较大的空间 不能获取局部变量的数量
- 调研：调研现在主流的调试器


- 实现：外部访问成员变量 ✅
- 实现：通过对象访问成员变量：如job_0.Running = false; 如 println_bool(job_0.Running) ✅
- 设计：self 不设计成系统关键字，也就是不再语法分析的时候，不把他当作是一个token ✅
- 实现：通过对象调用成员函数method，只是简单实现了，见 008-class/class-001.ring ✅
- 实现：在method中访问field，涉及到self关键字
- 实现：Class 定义里边重新进行编写   field 一个list  method 一个list
- 实现：构造method
- 实现：实现@public @private
- 理解：Diksam 在生成字节码的时候 同时记录与源代码之间的关系 LineNumber✅
- 实现：Ring实现记录字节码与源代码的映射关系✅
- 重构：简单重构一下代码✅
- 实现：main函数 @main
- 理解：Diksam 是如何实现源代码切分的，也就是require ✅
- 设计：Ring 多源代码输入的编译逻辑 ✅
- 实现：Ring 的package定义 和 import 导包 ✅
- 设计：Ring 多源代码输入的编译逻辑
  - 参考 GO env
- 调研：调试器

----------------------------------

## 2023-04-03周

实现面向对象
- 理解：diksam 面向对象、源代码切分、面向对象内存分配
- 设计：成员变量的场景  成员方法放在下一期
- 设计：面向对象的语法
- 实现：面向对象的语法
- 设计：虚拟机支持 面向对象的 内存分配
- 实现：虚拟机支持 面向对象的 内存分配
- 测试：面向对象的测试用例
- 设计：字节码二进制文件的生成、解析   好好参考一下 Lua


-----------------------------


## 错误提示

1. 使用有意义的错误消息：确保错误消息清晰明了，能够准确地指出问题所在。错误消息应该包含有关错误类型、位置和可能的解决方法的信息。
2. 提供上下文信息：在错误消息中提供尽可能多的上下文信息，以帮助用户理解问题。例如，可以包含相关的语法规则、输入符号和预期的符号等信息。
3. 提供详细的错误位置：在错误消息中指明具体的错误位置，以帮助用户快速定位问题。可以在错误消息中显示行号、列号或具体的代码片段。
4. 提供建议的修复方法：如果可能的话，可以在错误消息中提供一些建议的修复方法。这些建议可以是常见的错误修复方法，或者是根据上下文推断出的可能的解决方案。
5. 支持自定义错误处理：允许用户自定义错误处理函数，以便在发生错误时采取特定的行为。这样用户可以根据自己的需求自定义错误处理逻辑，例如记录错误日志、尝试自动修复等。
6. 提供详细的文档和示例：为bison工具提供详细的文档和示例，以帮助用户更好地理解和使用工具。文档应该包含有关错误处理的详细说明和示例代码，以及常见错误的解决方法。


要实现类似于Clang的智能化错误提示，需要进行更复杂的处理和分析。以下是一些可能的方法和技术：

1. 语法分析：使用更高级的语法分析技术，例如LLVM的Clang，可以检测和报告更复杂的语法错误。这可以包括缺失的分号、括号不匹配、不完整的语句等。
2. 语义分析：通过对代码进行语义分析，可以检测诸如未声明的变量、类型不匹配、函数调用错误等更高级的错误。这可能需要构建符号表、进行类型推断和类型检查等。
3. 数据流分析：通过数据流分析，可以检测和报告一些潜在的问题，例如未使用的变量、未初始化的变量、可能的空指针解引用等。
4. 代码规范检查：可以集成代码规范检查工具，例如Clang的静态分析器（Clang Static Analyzer）或其他工具，来检测代码中的潜在问题和违反规范的情况。
5. 模糊匹配和纠错：在发现错误时，可以使用模糊匹配和纠错技术，尝试推测用户的意图并提供可能的修复建议。例如，当用户在代码中输入了拼写错误时，可以通过推断正确的标识符并给出修复建议。
6. 上下文敏感的错误提示：利用上下文信息，可以更准确地定位错误和提供错误提示。例如，当用户在函数调用中传递错误的参数类型时，可以根据函数声明和调用上下文提供更具体的错误提示。



模糊匹配和纠错是一种常见的技术，用于推测用户的意图并提供可能的修复建议。以下是一些常见的模糊匹配和纠错方法：

1. 编辑距离：编辑距离是衡量两个字符串之间差异的度量，可以用于比较输入的错误单词与正确单词之间的相似程度。常见的编辑距离算法包括Levenshtein距离和Damerau-Levenshtein距离。可以计算输入单词与词典中的单词之间的编辑距离，并推荐与输入单词距离最近的正确单词作为纠错建议。
2. N-gram模型：N-gram模型是一种基于统计的语言模型，用于预测下一个词的可能性。可以使用N-gram模型来预测输入单词的下一个可能的单词，并给出基于上下文的纠错建议。
3. 词向量：词向量是将单词映射到连续向量空间的表示方法。可以使用词向量来计算输入单词与词典中的单词之间的相似度，并推荐与输入单词最相似的正确单词作为纠错建议。
4. 上下文信息：利用上下文信息，可以更准确地推测用户的意图和提供纠错建议。例如，当用户在代码中输入了拼写错误的标识符时，可以根据上下文中的其他标识符和语法规则推断正确的标识符。

以上方法可以结合使用，以提供更准确和智能的模糊匹配和纠错功能。具体的实现可以依赖于机器学习模型、自然语言处理技术和数据集的训练。例如，可以使用大规模的文本语料库进行训练，并构建模型来进行模糊匹配和纠错。同时，还可以根据特定领域的需求进行定制化的模型训练和优化。


上下文敏感的错误提示，这个怎么实现

实现上下文敏感的错误提示需要对代码的语法和语义进行深入分析，并根据上下文信息来判断可能的错误和提供相应的错误提示。以下是一些常见的实现方法：

1. 符号表：构建符号表来跟踪代码中的变量、函数和类型的声明和使用情况。通过分析符号表，可以检测未声明的变量、重复定义的变量、变量类型不匹配等错误，并在错误提示中提供准确的位置和相关信息。
2. 类型推断和类型检查：通过对代码进行类型推断和类型检查，可以检测类型不匹配、错误的函数调用、错误的操作符使用等错误。这需要构建和维护类型信息，并对代码进行静态分析。
3. 控制流分析：通过控制流分析，可以检测潜在的逻辑错误和代码路径不可达的情况。这可以帮助用户发现可能的错误逻辑和错误的条件分支。
4. 数据流分析：通过数据流分析，可以检测未使用的变量、未初始化的变量、可能的空指针解引用等问题。这需要跟踪变量的定义和使用情况，以及对数据流进行分析。
5. 模式匹配和规则检查：根据特定的代码规范和模式，可以检查代码中的潜在问题。例如，检测不安全的函数调用、内存泄漏、未释放的资源等。
6. 上下文窗口：维护一个上下文窗口，根据当前位置周围的代码片段提供错误提示。这可以包括相关的语法规则、变量使用情况、函数调用等信息，以帮助用户理解错误的上下文。
