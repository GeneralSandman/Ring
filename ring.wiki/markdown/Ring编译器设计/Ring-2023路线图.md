# Ring 2023年 规划表


> [!TIP|label:tip]
> 
> 世界上哪有不枯燥的事情呀。
> 
> 研究和学习一定要不甘寂寞，如果要是累了，就可以放天假呀。
>
> 静下心来，不要着急，人生是一个漫长的过程，造编译器也是一个漫长的过程，慢慢思考就好。
> 
> Ring还是非常有必要研究好的，虽然世界上有很多类似的语言，只要集中精力发展，Ring的未来还是会让现在的自己吃惊的！
> 


## 年总规划

1. 通读 diksam_v0.4 
   - https://github.com/GeneralSandman/diksam_v0.4
   - 里边还是有很多值得借鉴的地方
2. 通读 Lua 5.x版本
   1. 好好掌握 Lua的语法用法
   2. 力求完全掌握设计逻辑、包括协程、table
   3. 重新读那本 用Go语言实现Lua虚拟机
3. 完善Ring的基本功能
   1. 完善栈式虚拟机 ✅
   2. 面向对象 Class
   3. 数组 Array ✅
   4. 字符串 String ✅
   5. 完善语义分析 报错机制
   6. Any类型
   7. 实现可变参数 
   8. 完善内置 printf 函数  很重要  可变参数 format
   9. package 源代码的组织形式 import/package ✅
   10. 生成字节码 到二进制文件 解析字节码 Dump ByteCode (需要拆分出 编译前 和 加载虚拟机代码)
   11. linux man手册
   12. 完善Ring的数据类型 int double 是远远不够的 ✅
4. 完善Ring的高级功能
   1.  类型的强制转换 与 隐式转换
   2.  垃圾回收 Grabage Collection ✅
   3.  闭包 Closure
   4.  实现反射 获取变量的类型 参考 go ✅
   5.  优化内置 native-lib ✅
   6.  调试器 Debuger
   7.  交互式编程 
   8.  lsp
   9.  优化控制语句中  break continue return ✅
5. 实现相对完善的官方标准库 fmt sys math debug strings ✅
6. 将 栈式虚拟机 转为 寄存式虚拟机
7. 支持Ring Eval 
   1. e.g.  ./bin/lua eval "fmt::println_string("hello world");"
8. chatgpt + 智能终端 + ring -> 交互式入门ring
9. 学习函数式编程
10. 学习 Ocaml
11. 学习 V8


-----------------------------


## 参考资料汇总


1. Lua设计与实现 基于lua源码对其设计与具体实现进行剖析 https://www.zhihu.com/column/c_1097089416010567680
2. 《自己动手实现Lua：虚拟机、编译器和标准库》代码 https://github.com/GeneralSandman/luago-book
3. https://github.com/GeneralSandman/zhenhuli-lua-learn-node
4. 实现自己的编程语言 https://github.com/codecrafters-io/build-your-own-x#build-your-own-programming-language

1. 垃圾回收机制 https://journal.stuffwithstuff.com/2013/12/08/babys-first-garbage-collector/

1. 比较喜欢他的网站 https://maplant.com/ 特别喜欢那种特别老式的网站布局，人只会聚焦与内容


书籍
1. 《Lua设计与实现》https://github.com/lichuang/Lua-Source-Internal
2. 《自己动手实现Lua：虚拟机、编译器和标准库》


Lua
1. Lua的LG结构lua_State和global_State  
    https://zhuanlan.zhihu.com/p/102415312



-----------------------------




## 关于研究Lua的方法论和路线图

1. 不能有急于求成的心态, 创建编译器是一个很大的工作量, 需要长时间的付出和规划
2. 需要集中精力研究 Lua的源代码 和 Ring
3. 研究的方向主要集中于
- gc
- 字节码格式
- 


-----------------------------


## 关于研究Lua的哪个版本

lua 所有的版本 https://www.lua.org/versions.html

### 1. lua 4.0.1  https://github.com/GeneralSandman/lua-4.0.1
   
简单, stack-based virtual machine 
可能方便

时间有点久远, 2002 年发布的, 

gc算法比较老旧
没有 coroutine

### 2. lua 5.4.4  https://github.com/GeneralSandman/lua-5.4.4

可能理解起来比较复杂, 

但是相关的设计都是比较现代的

TIP: 推荐 Lua 5.4.4 版本作为研究对象.

## 《自己动手实现Lua：虚拟机、编译器和标准库》


这个书籍有几个地方其实我不太认可, 就是在实现 virtual machine stack 的时候, 使用的golang 的 interface{} 去存储数据,
不太认可这样的办法, 可能借用Golang的特性, 简化的虚拟机的实现方式

基于 Lua 5.4.4


### 1. 第二章 ———— 二进制chunk格式详解

了解Lua 5.4.4 版本的 bytecode的基本格式, 知道是如何解析的, 并且实现了解析 Lua Bytecode.
header: 校验码, 如何加载
body: proto 的基本格式


### 2. 第三章 ———— 指令集

介绍Lua虚拟机指令集和指令编码格式, 对指令进行解码.

TODO: 这里还没通过代码实现


### 3. 第四章 至 第六章

主要介绍如何要实现一个stack-based virtual machine, 可以解释执行大概一半的Lua虚拟机指令.

但是自己在 Ring 已经实现了 stack-based virtual machine, 其实这三章可以暂时略过.


### 4. 第七章 至 第十二章

介绍 表, 函数调用, Closure&Upvalue, 元编程, 迭代器, 异常和错误处理

TODO: Closure&Upvalue

-----------------------------



## 想要借鉴的一些语法


### 1. lua 索引
```
索引
对 table 的索引使用方括号 []。Lua 也提供了 . 操作。

t[i]
t.i                 -- 当索引为字符串类型时的一种简化写法
gettable_event(t,i) -- 采用索引访问本质上是一个类似这样的函数调用


> site = {}
> site["key"] = "www.runoob.com"
> print(site["key"])
www.runoob.com
> print(site.key)
www.runoob.com
```

-----------------------------

## 工作内容流程细分

将工作细化为以下几类工作：
- 调研: 深度理解某项功能
- 设计: 需求分析、规划，设计语法，设计功能，设计某项功能, 代码实现
- 测试: 完善测试用例
- 重构: 代码逻辑的重构
- 优化: 优化Ring本身的不足

-----------------------------

## 测试集

```
2023-12-10

[Result]:
Pass/All = 204/204
NotTest  = 5
Usetime:   8s

```

1. bug
debug::debug_assert(reflect::typeof(bool_value) == "bool");
这样判断会失败。

2. bug
global value 来说，全局变量没有进行初始化。




-----------------------------

## 要完善的测试用例

1. function return class object
2. Pass class object as parameter to function
3. Pass string as parameters to function 
4. Return class object from function
5. Return string from function
6. Array & ClassObject
7. Array & String  ✅
8. Test array bool(global/local/argument/return)  ✅ 
9. Test array int(global/local/argument/return)  ✅ 
10. Test array double (global/local/argument/return)  ✅ 
11. Test array string(global/local/argument/return)  ✅ 
12. Test array class object(global/local/argument/return)

-----------------------------

## 2023-11-27周

### *A. 设计: 函数调用 RVM_CallInfo 使用链表组织起来*


### *B. 设计: 规划Ring 前端&后端的解耦*

目前在 RVM 执行字节码的过程中, 引用到了 AST 相关的数据, 耦合严重, 不利于后续的开发.

所以将 AST 中所有的数据结构都要进行销毁, 推进前端和后端的解耦, 为后续导出字节码奠定基础.

主要销毁的包括: 语句, 表达式, 函数, 类, 变量, 包

需要copy的:
- TypeSpecifier: 在rvm中, 根据变量的类型进行初始化
- RVM_Class:   rvm中, class-object 的初始化

-----------------------------

## 2023-11-27周

### *A. 设计: 类的数组*

1. `类-数组` 类的成员支持 更新value

```
        global_job_array_0[index].Running = true;

```

这里其实有一个隐喻, 是取出 global_job_array_0[index] 的指针, 然后进行更新值


-----------------------------

## 2023-11-20周

### *A. 设计: vmcode 需要记录源代码的行数*

#### 1. 要保证记录的准确性

#### 2. 能够输出源代码和字节码的映射


### *B. 设计: 类中放string*

### *C. 设计: 类的数组*

1. 声明`类` & 声明`类-数组` ✅

```
    typedef class Job {
        field bool    Running;
        field int     JobID;
        field double  Score;
    }

    var Job[] global_job_array_0;
```

2. `new`操作符为`类-数组`分配空间 ✅

```
    global_job_array_0 = new Job[200];
```


3. 通过整数索引访问数组内的元素 ✅

```
    fmt::println_bool(global_job_array_0[0].Running);
    fmt::println_int(global_job_array_0[0].JobID);
    fmt::println_double(global_job_array_0[0].Score);
```

4. for 循环访问数组内的类成员变量 ✅

```
    var int index = 0;
    for(index = 0; index < 200; index = index + 1) {
        fmt::println_bool(global_job_array_0[index].Running);
        fmt::println_int(global_job_array_0[index].JobID);
        fmt::println_double(global_job_array_0[index].Score);
    }
```


5. for-range 支持`类-数组`   ✅ 

```
    var Job job_value;

    for(job_value in range global_job_array_0) {
        fmt::println_bool(job_value.Running);
        fmt::println_int(job_value.JobID);
        fmt::println_double(job_value.Score);
    }
```

6. push 支持`类-数组`    ✅ 

```
    var Job global_job_value_0;
    global_job_value_0 = Job{
       Running: true,
       JobID: 200, 
       Score: 200.1
    };

    // push 一个 Job 变量
    push(global_job_array_0, global_job_value_0);

    // push 一个 Job 常量
    push(global_job_array_0, Job{
        Running: false,
        JobID: 201, 
        Score: 201.14
    });
```

7. pop 支持`类-数组`   ✅ 

```
    var Job global_job_value_0;

    // 从 global_job_array_0 的尾部 pop, 并获取尾部值
    global_job_value_0 = pop(global_job_array_0);

    fmt::println_bool(global_job_value_0.Running);
    fmt::println_int(global_job_value_0.JobID);
    fmt::println_double(global_job_value_0.Score);

```

8. 通过 索引为 数组内的类元素赋值  ✅ 

```
    // 通过 Job 常量 直接赋值
    global_job_array_0[0]  = Job{
        Running:  false,
        JobID:    0,
        Score:    0.0
    };

    // 通过 Job 变量 进行赋值
    global_job_value_0  = Job{
        Running:  true,
        JobID:    3,
        Score:    33.33
    };
    global_job_array_0[3] = global_job_value_0;
```

8. TODO: 

函数参数变量传递

函数返回值传递





### *D. 优化: fix_ast*

fix AST 的过程中需要对每个 expression 的 conver_type 依次进行修正

1. 要解决多级嵌套的问题

```
global_class_array_0[0].Running
```


### *E. 设计: 内存池* ✅

是否有必要要考虑设计内存池, 这样在分配动态内存的时候, 直接从内存池中去取, 
能够减少内存碎片, 减少分配的速度, 同时还能检查 RVM 垃圾回收是否正常, 是否有内存泄漏

现在没有内存池的设计就是: 分配内存比较随意, 没有统一在一起, 而且查看内存分配的空间不方便, 比较粗放.

但是内存池会不会拖慢内存的分配、释放速度, 得好好测试一下, 开启内存池/未开始内存池.

所以这个功能还是急需的.

大三的时候设计过一款内存池, 所以要看看是否能够复用一下.



-----------------------------


## 2023-11-13周

### *A. 设计: import时, 各种异常情况都需要check, 人性化的报错*

#### 1. 用户导入包的顺序是可以任意的
#### 2. 用户导入的包不存在
#### 3. 用户导入的包不合法
#### 4. 用户导入的包重复



### *B. 设计: 数组/字符串的动态增长* ✅

#### 1. 如何往数组中添加元素, push 用来动态增长

```
push(array_value, 1);

value = pop(array_value);
```


注意: 
push的时候, 必须要保证 array_value 已经被new过了,  

`array_value = new int[100];`

这里看看后续是不是需要优化


#### 2. pop 用来删除最后一个元素, 删除元素之后获得最后一个元素

```
value = pop(array_value);
```

### *C. 调研: JVM switch 语句* 

### *D. 设计: 数组按照2倍增长* 

bug:

```
global_bool_array_0 = new bool[0];

push(global_bool_array_0, true);

```

这样动态增长的时候, capacity 算的有问题, 因为*2, 所以一直是0


### *E. 设计: VM, 往vm中push value的时候, 没有pop的时候, 函数返回会报错, 需要对栈上的空间进行回收, call_info 的问题*

### *F. 设计: 数组+对象*

### *G. 设计: to_string* ✅

```
string_value = to_string(bool_value);
string_value = to_string(int_value);
string_value = to_string(double_value);
```

添加新的字节码:
RVM_CODE_BOOL_2_STRING
RVM_CODE_INT_2_STRING
RVM_CODE_DOUBLE_2_STRING


### *H. 设计 fmt::println() fmt::printf()*

### *G. 009-package 测试用例继续拆分一下*


-----------------------------



## 2023-11-06周




### *B. 设计: 数组/字符串 如何获得数组的长度&容量*  ✅


添加四个专业的字节码

```
    RVM_CODE_PUSH_ARRAY_LEN,
    RVM_CODE_PUSH_ARRAY_CAPACITY,
    RVM_CODE_PUSH_STRING_LEN,
    RVM_CODE_PUSH_STRING_CAPACITY,
```

usage:    
```
len(string_variable)
capacity(string_variable)
len(array_variable)
capacity(array_variable)
```

e.g.

```
var string local_string_value_0;

fmt::println_int(len(local_string_value_0));
fmt::println_int(capacity(local_string_value_0));


var bool[] local_bool_array_0;

fmt::println_int(len(local_bool_array_0));
fmt::println_int(capacity(local_bool_array_0));
```


### *C. 设计: 数组/字符串的越界访问*

1. 以下这几个函数在vm调用的时候, 如果超过数组的边界, 应该抛出异常, 在这里返回一个错误码, RUNTIME_ERR_OUT_OF_ARRAY_RANGE

- rvm_array_get_bool
- rvm_array_get_int
- rvm_array_get_double
- rvm_array_get_string

- rvm_array_set_bool
- rvm_array_set_int
- rvm_array_set_double
- rvm_array_set_string

2. 需要在访问数组的时候做一下处理, 报错要人性化, 能够打印出当时的调用栈信息


### *D. 设计: 数组/字符串的 for range 访问*  ✅

1. 支持了 bool[], int[], double[], string[]  的range操作

2. 语法示例:


Usage:
```
var bool[] bool_array_0 = bool[]{false, true, false};

var int index;
var bool value;
for(value = range bool_array_0) {
    fmt::println_bool(value);
}
```

Output

```
false
true
false
```

3. VM层面添加几个专用的字节码: 

```
    RVM_CODE_FOR_RANGE_ARRAY_BOOL,
    RVM_CODE_FOR_RANGE_ARRAY_INT,
    RVM_CODE_FOR_RANGE_ARRAY_DOUBLE,
    RVM_CODE_FOR_RANGE_ARRAY_STRING,
    RVM_CODE_FOR_RANGE_ARRAY_OBJECT,
    RVM_CODE_FOR_RANGE_STRING,
    RVM_CODE_FOR_RANGE,
    RVM_CODE_FOR_RANGE_FINISH,
```

### *E. 支持给数组中的元素赋值*  ✅

1. 支持对 bool[], int[], double[], string[] 中的元素进行复制

2. 语法示例:


Usage:
```
  var bool[] global_bool_array_0  = new bool[20];

  global_bool_array_0[0] = true;
```

### *F. 修正*  ✅

改回去
```
    if (declaration->type->next->kind == RING_BASIC_TYPE_BOOL) {
        generate_vmcode(executer, opcode_buffer, RVM_CODE_PUSH_ARRAY_BOOL, (2 << 8) | (1), array_index_expression->line_number);
    } else if (declaration->type->next->kind == RING_BASIC_TYPE_INT) {
        generate_vmcode(executer, opcode_buffer, RVM_CODE_PUSH_ARRAY_INT, (2 << 8) | (1), array_index_expression->line_number);
    } else if (declaration->type->next->kind == RING_BASIC_TYPE_DOUBLE) {
        generate_vmcode(executer, opcode_buffer, RVM_CODE_PUSH_ARRAY_DOUBLE, (2 << 8) | (1), array_index_expression->line_number);
    } else if (declaration->type->next->kind == RING_BASIC_TYPE_STRING) {
        generate_vmcode(executer, opcode_buffer, RVM_CODE_PUSH_ARRAY_STRING, (2 << 8) | (1), array_index_expression->line_number);
    } else {
        printf("error: array index expression only support bool[] int[] double[] string[]\n");
        exit(1);
    }
```

---------------------


## 2023-10-30周

   

1. 修正一下 class object 相关的gc  ✅
2. 通过函数传递 class object
   1. 可以通过函数传递 但是是 浅copy,  ✅
   2. 需要优化成 深度 copy
3. array & class object
4. array & string
   1. 命名array-string: var string[] string_array; ✅
   2. 分配空间: string_array = new string[10]; ✅
   3. 分配空间初始化: string_array = string[]{"a"}; ✅
   4. 访问array-string: fmt::println_string(string_array[0]); ✅
   5. gc heap_size 计算的不对
   6. 还没有 check gc是否正常
   7. 内存分布还得好好重构一下
5. 数组访问 要panic报错 index越界
6. 支持 for range
7. 优化语义检查
8. string的动态增长
9. array的动态增长
10. 有了 var 之后, 是不是让 匿名函数变得复杂了
11. ast 中 每个 expression 都要 fix conver_type (TypeSpecifier*)
12. 修正 vm execute 过程中 写死的 local_variable_count = 20;

13. class-object 的初始化 暂时不用 constructor函数, 使用类似于Golang的 列表初始化

> var Job job_0 = Job{
> 
>    Running: false,
> 
>    JobID: 0,
> 
>    Score: 0.0
> 
> };
>

遗留问题:
    0. 简单测试没有问题  ✅
    1. 初始化列表的数量 必须要跟 class成员变量的数量 一致
    2. 初始化列表的顺序 必须要跟 class成员变量的顺序 一致

class 内部的 constructor 函数是不是要废弃
constructor 应该作为默认的初始化函数
> var Job job_0(); // 这里就是去调用 constructor函数
>


---------------------


## 2023-10-23周

1. 如何判断rvm上object是否发生了深度copy, 同时尽量不要通过在rvm中debug print的方式  ✅
> 通过 fmt::println_pointer 来打印实际存储数据的地址
> 
2. 重构 heap 内存分配 ✅
3. 通过工具 可以将 Ring 虚拟机指令集生成一个 markdown表格 ✅
> make tool_gen_vmcode_doc && ./bin/tool_gen_vmcode_doc
4. 函数 返回 array string object 去完成深度copy ✅
5. 函数可以返回 数组  ✅
6. 可以传递数组 给 函数  ✅
7. bug 数组不能赋值
8.  使用 bool 数组 (new bool[10], bool[]{})  ✅
> Usage:
> 
> var bool[] bool_array_0 = new bool[10];
>
> var bool[] bool_array_1 = bool[]{false, true};
9.  bug  ✅
    - string 的初始化, 默认值, 都要重新审视一下
    - fmt::println_string 有bug 如果数据很多会有bug
10. 实现一个简单的垃圾回收机制 mark&swap  ✅
11. native 函数 添加 vm::grbage_collect  ✅
12. Add native function vm::heap_size  ✅
13. 计算 heap_size 的方式需要重新计算  ✅ 
14. 要区分 length size capacity ✅

## 2023-10-16周

1. 编译阶段和运行阶段某些工作要拆分开来
    某些结构体要及时释放, 不要相互依赖
2. 重新组织一下 std package 测试集
3. 每行后边的; 是不是可以去掉
4. 完善文档 Ring编译器开发规范 ✅
5. 重构一些代码和注释  ✅
6. 完善优化一下 vm_debug ✅
7. 完善一下 debug summary info  ✅
8.  完成一个简单的垃圾回收机制 mark&swap ✅


## 2023-10-07周

1. 构想、实现 一下 reflect package ✅
2. 构想、实现 一下 any 类型 ✅
3. 把一键安装完善一下 https://cloud.tencent.com/developer/article/1884133
4. reflect 需要反射 bool int double string class array ✅
5. any 类型需要在语义分析的时候进行检查
6. 语法上还要支持可变参数 function println(var any... any_value_list); ✅
7. 函数内 读取可变参数列表，得需要某种方式，e.g.  for value := range any_value_list {}
8. golang 这个 example这个网站可以好好学习一下 ✅
    https://gobyexample.com/
    https://github.com/mmcgrana/gobyexample
    生成ring的example website    https://example.ring.wiki
9. 构想、实现一下 os io std-package


### bug 1

```
    function test(var any any_value) {
        fmt::println_string(reflect::typeof(any_value));
    }

    error: generate opcode error
```

### bug 2
    
```
function test(var int... int_value) {
}


@main
function main() {
    var int int_value_0;
    var int int_value_1;

    test(int_value_0, int_value_1);
}
```
执行的时候会挂掉

### reflect 构想 通过函数名字获取函数类型 

```
function test(var bool bool_value, var int int_value)->(string) {

}

reflect::typeof(test);  // function(bool, int)->(string)
```

### 构想一下 for range

```

var int[] int_array;
for (key, value = range int_array) {
    fmt::println(key);
    fmt::println(value);
}
```



## 2023-09-25周

## 2023-09-18周

1. 完善类数组
2. 函数传递数组、类、类数组
3. 把一键安装完善一下
4. 再完善一下语义分析
5. 想着把 import 关键字 改成 using  评估一下


## 2023-09-11周

## 2023-09-04周

## 2023-08-28周


1. 完成一个简单的垃圾回收机制 mark&swap
2. 通过RVM_RuntimeHeap 去分配内存
3. 自动化测试automated-testing.sh展示有点简陋，看看是否可以用 GoTest来搞定自动化测试
4. 优化语义分析
5. 优化 break continue return goto
6. 修复一下测试用例中的bug ✅
    6.1 minus运算符 操作 double literal的时候失败  ✅
    6.2 var string string_value; 定义之后不使用，不赋值，就进行访问，会内存错误  ✅
7. 好好完善一下 Makefile 各种debug宏 ✅
8. 添加完善一键安装的功能
   1. curl -sSL https://ring.wiki/install.sh | sh  ✅
   2. 在每发布一个 release版本的时候，需要在cos上自动创建对应版本的源码，install安装脚本。通过 github action
9. 实现 jump 跳转指令 重新评估一下 ✅
10. std/vm 标准库获取heap_size native函数需要支持返回值 ✅
11. 要把 invoke_native_function 和 invoke_derive_function 的逻辑合起来
12. bug , 如果一个函数有返回值，但是没有收集返回值，会报错， vm::heap_size() 就会报错 ✅
13. 优化 std lib vm ✅

## 2023-08-21周

1. 完成一个简单的垃圾回收机制 mark&swap
2. 通过RVM_RuntimeHeap 去分配内存
3. 自动化测试automated-testing.sh展示有点简陋，看看是否可以用 GoTest来搞定自动化测试
4. github action workflow 自动构建release 预编译版本 ✅
5. 调研：以下几种编译方式 ✅
    - 源代码安装
    - 预编译安装
    - apt yum brew 软件源安装

6. sizeof() typeof()
7. flex bison 记录的行号不是太准确，比如说，对于function的定义，他会跑到最后一行，应该定位到function 定义的第一行
8. function variable package 的名字不可以一样
clang：报错
 redefinition of 'a' as different kind of symbol
1. ring man <keyword> 快速提示语法结构 ✅

## 2023-08-14周

1. 优化string
    - 动态内存分配 size capacity append 增长
    - 通过索引访问
    - 优化字符串的拼接
    - fmt::to_string 函数，这样的话，是需要反射的，因为传入的变量可以是 int double string
    - size() 获取string的长度
    - fmt::printf("string_value_1 value:{}, size:{}\n", string_value_1, size(string_value_1)); 这也是需要反射
2. 优化完成string之后，优化 fmt 函数， fmt::println() -> io::write(var string str)
3. 优化报错信息 ✅
4. 完成一下测试用例
    函数变量传递 array string class变量
5. 完善 array class
6. 完善 array string
7. 完善多维数组

## 2023-08-07周

1. 优化 runtime_stack 空间，要通过局部变量的数量来动态增长 空间
2. 想清楚全局变量、局部变量 初始化的时机 ✅
2.1 用户在使用ring的时候，不能在 global{} 块中进行全局变量的初始化 ✅
    必须要通过 function init(){} 对全局变量进行初始化
    如果main包import 了 fmt:
        函数的调用顺序为：fmt::init() -> main::init() -> main::main()

测试：在global中 定义全局变量时，初始全局变量。

3. 优化报错信息  将所有的printf 改成 compile_error runtime_error
4. 报错脚本的自动化测试✅

```
通过 ErrorReportContext 来实现
ErrorReportContext context = {

};
ring_compile_error(&context); // 每次ring_compile_error 都要添加一下错误次数，错误次数多了才要退出
```

错误信息:

```
./test/998-error-report/error-000.ring:10:0:
|       a;
|       ^......use undeclared variable identifier `a`; E:ERROR_UNDECLARED_IDENTIFIER
Advice: definite variable `a` like: `var bool|int|double|string a;`

./test/998-error-report/error-000.ring:10:0:
|       a;
|       ^......use undeclared variable identifier `a`; E:ERROR_UNDECLARED_IDENTIFIER
Advice: definite variable `a` like: `var bool|int|double|string a;`


1 error generated.

```

compile
synx_
fix_ast

应该细分一下，首先进行语义分析，将错误尽可能的报出来，同时还要积攒数量。
不然的话，fix_ast 可能会出错。
语义分析的时机，编译完成之后，fix_ast 之前。
语义分析的对象是 Package

但是目前一个Package 里边只能有一个PackageUnit 也就是一个包只能有一个文件
一个package 中 可以含有多个 global{} 块。
一个package 中 可以含有多个 init() function{} , 需要通过 @init-priority:1 来生命初始化的优先级

5. 还有一个没有搞明白
    ring 的前端是依赖两个工具flex 和 bison
    如果某个输入有语法错误，那么bison将会直接退出，如何更好的做语法检测。这个还真不太好搞。


-----------------------------

## 2023-07-31周

1. 全面重构类型系统 ✅
2. 修复 int[] double[] 的相关bug ✅
3. 支持数组的初始化赋值，var int[] array = int[]{1, 2, 3, 4}; ✅


-----------------------------

## 2023-07-24周

1. global block 可以有多个，e.g.

```
global {
}
global {
}
```

2. 实现 var int[] array ✅
3. 实现 new int[10], 暂时只支持一维数组 ✅
4. 实现 array = new int[10]; ✅
5. 在 vm 中要实现类型map 的查找和匹配

-----------------------------

## 2023-06-05周

1. 通读《自己动手实现Lua：虚拟机、编译器和标准库》 1-13章
2. 对学到的支持 优化Ring 数组
3. make install bug & 标准库路径写死的bug ✅


-----------------------------

## 2023-05-29周

1. 自己建立一个新的项目，目的是对Lua的字节码有一个较深的理解
   1. 深度学习Lua字节码
   2. 参考 《自己动手实现Lua：虚拟机、编译器和标准库》 1-13章
   3. 参考 https://github.com/GeneralSandman/luago-book
   4. 自己的项目 就是通过CPP来解析Lua的字节码
   5. 项目地址：https://github.com/GeneralSandman/zhenhuli-lua-learn-node


1. zhenhuli-lua-learn-node
   1. 完成了第二章的学习，并可以顺利通过CPP完成对第二章要点的完全掌握。
2. 对知乎专栏Lua模块精讲的学习
   1. Lua设计与实现 基于lua源码对其设计与具体实现进行剖析 https://www.zhihu.com/column/c_1097089416010567680


- 调研标准库的方式
- 参考lua 的 linux man 手册的编写
    https://linux.cn/article-10130-1.html
- Lua 二进制 Chunk的形式，写一个解析程序。学习《自己动手实现Lua：虚拟机、编译器和标准库》 1-13章
- https://github.com/GeneralSandman/luago-book
- lua设计与实现 https://www.zhihu.com/column/c_1097089416010567680

- 思考：全局变量初始化的时机


-----------------------------

## 2023-04-23周

- import 导入包
- std 标准包
- 完善所有的测试用例
- 优化函数的 return list
- 优化 基础 类型 string

- 实现：import 的相关功能 通过import 使用package内的函数     操作符使用 ::  方法的定义也使用 ::✅
- 实现：导入std-fmt包，使用fmt相关库函数，同时要设计好native函数要怎样register才能更方便    --有bug  优先fix
- 实现：import 的相关功能 通过import 使用package内的函数     操作符使用 ::  方法的定义也使用 ::
  - package::函数 ✅
- 实现：导入std-fmt包，使用fmt相关库函数，同时要设计好native函数要怎样register才能更方便     ✅
- 实现：import 的相关功能 通过import 使用package内的函数     操作符使用 ::  方法的定义也使用 ::
  - package::全局变量 ✅
  - package::类定义
- 测试：把所有的测试case统一做了更新  ✅
- 实现：解决 std package 路径的问题
- 调研：调试器  ✅
- 优化：记录原始行号的功能  ✅
- 优化：优化全局变量的一些逻辑  ✅
- 重构：重构了一些代码逻辑  ✅


- 实现：函数的返回类型
- 优化：函数的调用栈
- 优化：函数的局部变量
- 实现：method 使用 self关键字


- 实现：类的构造函数
- 修复：全局变量的初始化
- 修复：类的局部变量的初始化
- 优化：统一 execute 的时候 调用 native derive  function 的方式
- 设计：全局变量初始化的时机 

-----------------------------


## 2023-04-17周

1. 关于源代码切分
- 实现：package import 
- 实现：分package编译 生成字节码 链接

包的名称 不能 和类变量的名称一样，不然会有逻辑问题

- 实现：PacageUnit等 static变量的优化 
- 实现：根据import-package名称去访问 package内的function
- 优化：单文件内 对象的访问
- 实现：class method使用self关键字
- 实现：class method参数和返回值
- 实现：class 构造method
- 测试：完善 class 的相关测试
- 实现：好好实现 std-fmt 库，同时优化 native函数
- 实现：实现比较好用printf函数
- 设计：设计可变参数
- 实现：function method 返回值的严格检验 与 返回值处理

- 实现：源代码的切分编译 ✅
- 实现：编译器从C语言全部转为C++ ✅
- 重构：源代码没有变量编译错误 bug  ✅
- 重构：源代码import为空时编译错误 bug  ✅
- 重构：创建AST时，将 class_definition_list 和 function_list 转为 CPP-vector，更好的管理内存 ✅
- 实现：源代码的切分编译、打包 ✅
- 实现：导入使用 package ✅
- 实现：定义package ✅
- 实现：main 函数  ✅
- 优化：一些编译告警  ✅
- 修复：一些全局变量的默认初始值的bug  ✅
- 实现：去除编译warn告警，提高编译速度 ✅
- 实现：全局变量的定义采用一个比较好的 方式 global{}  ✅
- 实现：import 的相关功能 通过import 使用package内的函数     操作符使用 ::  方法的定义也使用 ::


-----------------------------


## 2023-04-10周

1. 实现面向对象的部分逻辑
- 实现：面向对象 field
- 实现：面向对象 method
- 实现：属性@public @private @constructor

2. 关于字节码二进制
- 实现：源代码与字节码的对应关系 更好的debug
- 理解：Lua字节码的定义，如果生成字节码，如何解析字节码


3. 关于源代码切分
- 实现：package import 
- 实现：分package编译 生成字节码 链接

4. 一些想到的问题
- 实现：属性 @format 应用到某个类的成员函数 定义重载打印对象数据结构的
- 虚拟机：当时设计的不足，不如预先分配一个比较大的空间 不能获取局部变量的数量
- 调研：调研现在主流的调试器


- 实现：外部访问成员变量 ✅
- 实现：通过对象访问成员变量：如job_0.Running = false; 如 println_bool(job_0.Running) ✅
- 设计：self 不设计成系统关键字，也就是不再语法分析的时候，不把他当作是一个token ✅
- 实现：通过对象调用成员函数method，只是简单实现了，见 008-class/class-001.ring ✅
- 实现：在method中访问field，涉及到self关键字
- 实现：Class 定义里边重新进行编写   field 一个list  method 一个list
- 实现：构造method
- 实现：实现@public @private
- 理解：Diksam 在生成字节码的时候 同时记录与源代码之间的关系 LineNumber✅
- 实现：Ring实现记录字节码与源代码的映射关系✅
- 重构：简单重构一下代码✅
- 实现：main函数 @main
- 理解：Diksam 是如何实现源代码切分的，也就是require ✅
- 设计：Ring 多源代码输入的编译逻辑 ✅
- 实现：Ring 的package定义 和 import 导包 ✅
- 设计：Ring 多源代码输入的编译逻辑
  - 参考 GO env
- 调研：调试器

----------------------------------

## 2023-04-03周

实现面向对象
- 理解：diksam 面向对象、源代码切分、面向对象内存分配
- 设计：成员变量的场景  成员方法放在下一期
- 设计：面向对象的语法
- 实现：面向对象的语法
- 设计：虚拟机支持 面向对象的 内存分配
- 实现：虚拟机支持 面向对象的 内存分配
- 测试：面向对象的测试用例
- 设计：字节码二进制文件的生成、解析   好好参考一下 Lua


-----------------------------


## 错误提示

1. 使用有意义的错误消息：确保错误消息清晰明了，能够准确地指出问题所在。错误消息应该包含有关错误类型、位置和可能的解决方法的信息。
2. 提供上下文信息：在错误消息中提供尽可能多的上下文信息，以帮助用户理解问题。例如，可以包含相关的语法规则、输入符号和预期的符号等信息。
3. 提供详细的错误位置：在错误消息中指明具体的错误位置，以帮助用户快速定位问题。可以在错误消息中显示行号、列号或具体的代码片段。
4. 提供建议的修复方法：如果可能的话，可以在错误消息中提供一些建议的修复方法。这些建议可以是常见的错误修复方法，或者是根据上下文推断出的可能的解决方案。
5. 支持自定义错误处理：允许用户自定义错误处理函数，以便在发生错误时采取特定的行为。这样用户可以根据自己的需求自定义错误处理逻辑，例如记录错误日志、尝试自动修复等。
6. 提供详细的文档和示例：为bison工具提供详细的文档和示例，以帮助用户更好地理解和使用工具。文档应该包含有关错误处理的详细说明和示例代码，以及常见错误的解决方法。


要实现类似于Clang的智能化错误提示，需要进行更复杂的处理和分析。以下是一些可能的方法和技术：

1. 语法分析：使用更高级的语法分析技术，例如LLVM的Clang，可以检测和报告更复杂的语法错误。这可以包括缺失的分号、括号不匹配、不完整的语句等。
2. 语义分析：通过对代码进行语义分析，可以检测诸如未声明的变量、类型不匹配、函数调用错误等更高级的错误。这可能需要构建符号表、进行类型推断和类型检查等。
3. 数据流分析：通过数据流分析，可以检测和报告一些潜在的问题，例如未使用的变量、未初始化的变量、可能的空指针解引用等。
4. 代码规范检查：可以集成代码规范检查工具，例如Clang的静态分析器（Clang Static Analyzer）或其他工具，来检测代码中的潜在问题和违反规范的情况。
5. 模糊匹配和纠错：在发现错误时，可以使用模糊匹配和纠错技术，尝试推测用户的意图并提供可能的修复建议。例如，当用户在代码中输入了拼写错误时，可以通过推断正确的标识符并给出修复建议。
6. 上下文敏感的错误提示：利用上下文信息，可以更准确地定位错误和提供错误提示。例如，当用户在函数调用中传递错误的参数类型时，可以根据函数声明和调用上下文提供更具体的错误提示。



模糊匹配和纠错是一种常见的技术，用于推测用户的意图并提供可能的修复建议。以下是一些常见的模糊匹配和纠错方法：

1. 编辑距离：编辑距离是衡量两个字符串之间差异的度量，可以用于比较输入的错误单词与正确单词之间的相似程度。常见的编辑距离算法包括Levenshtein距离和Damerau-Levenshtein距离。可以计算输入单词与词典中的单词之间的编辑距离，并推荐与输入单词距离最近的正确单词作为纠错建议。
2. N-gram模型：N-gram模型是一种基于统计的语言模型，用于预测下一个词的可能性。可以使用N-gram模型来预测输入单词的下一个可能的单词，并给出基于上下文的纠错建议。
3. 词向量：词向量是将单词映射到连续向量空间的表示方法。可以使用词向量来计算输入单词与词典中的单词之间的相似度，并推荐与输入单词最相似的正确单词作为纠错建议。
4. 上下文信息：利用上下文信息，可以更准确地推测用户的意图和提供纠错建议。例如，当用户在代码中输入了拼写错误的标识符时，可以根据上下文中的其他标识符和语法规则推断正确的标识符。

以上方法可以结合使用，以提供更准确和智能的模糊匹配和纠错功能。具体的实现可以依赖于机器学习模型、自然语言处理技术和数据集的训练。例如，可以使用大规模的文本语料库进行训练，并构建模型来进行模糊匹配和纠错。同时，还可以根据特定领域的需求进行定制化的模型训练和优化。


上下文敏感的错误提示，这个怎么实现

实现上下文敏感的错误提示需要对代码的语法和语义进行深入分析，并根据上下文信息来判断可能的错误和提供相应的错误提示。以下是一些常见的实现方法：

1. 符号表：构建符号表来跟踪代码中的变量、函数和类型的声明和使用情况。通过分析符号表，可以检测未声明的变量、重复定义的变量、变量类型不匹配等错误，并在错误提示中提供准确的位置和相关信息。
2. 类型推断和类型检查：通过对代码进行类型推断和类型检查，可以检测类型不匹配、错误的函数调用、错误的操作符使用等错误。这需要构建和维护类型信息，并对代码进行静态分析。
3. 控制流分析：通过控制流分析，可以检测潜在的逻辑错误和代码路径不可达的情况。这可以帮助用户发现可能的错误逻辑和错误的条件分支。
4. 数据流分析：通过数据流分析，可以检测未使用的变量、未初始化的变量、可能的空指针解引用等问题。这需要跟踪变量的定义和使用情况，以及对数据流进行分析。
5. 模式匹配和规则检查：根据特定的代码规范和模式，可以检查代码中的潜在问题。例如，检测不安全的函数调用、内存泄漏、未释放的资源等。
6. 上下文窗口：维护一个上下文窗口，根据当前位置周围的代码片段提供错误提示。这可以包括相关的语法规则、变量使用情况、函数调用等信息，以帮助用户理解错误的上下文。
